<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Letter Grid with Multiple Letter Instances</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            user-select: none;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 10px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            touch-action: none;
        }
        .grid-item {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e0e0e0;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px;
            user-select: none;
        }
        .grid-item.selected {
            background-color: #e9ba3a;
            transform: scale(1.0);
        }
        #trail {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="grid-container" id="letterGrid"></div>
    <svg id="trail" width="100%" height="100%"></svg>

    <script>
        class LetterGrid {
            constructor() {
                this.grid = document.getElementById('letterGrid');
                this.trail = document.getElementById('trail');
                this.letters = this.generateRandomLetters();
                this.isDrawing = false;
                this.selectedLetters = [];
                this.lastCell = null;

                // Use 16 here to make it easier to find for changes
                this.gridSize = Math.sqrt(16);
                this.tolerance = 20;

                this.initializeGrid();
                this.attachEventListeners();
            }

            generateRandomLetters() {
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                return Array.from({length: 16}, () => 
                    alphabet[Math.floor(Math.random() * alphabet.length)]
                );
            }

            initializeGrid() {
                this.grid.innerHTML = '';
                this.letters.forEach((letter, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-item';
                    cell.textContent = letter;
                    cell.dataset.letter = letter;
                    cell.dataset.index = index;
                    this.grid.appendChild(cell);
                });
            }

            attachEventListeners() {
                this.grid.addEventListener('mousedown', this.startDrawing.bind(this));
                this.grid.addEventListener('mousemove', this.mouseDraw.bind(this));
                document.addEventListener('mouseup', this.stopDrawing.bind(this));

                this.grid.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.grid.addEventListener('touchmove', this.handleTouchMove.bind(this));
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            handleTouchStart(e) {
                e.preventDefault();

                this.startDrawing(e);
            }

            handleTouchMove(e) {
                e.preventDefault();

                // Work out where we have dragged to and process it
                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);

                if (element) {
                    this.draw(element, touch.clientX, touch.clientY);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();

                this.stopDrawing();
            }

            startDrawing(e) {
                if (e.target.classList.contains('grid-item')) {
                    this.isDrawing = true;
                    this.selectedLetters = [{
                        letter: e.target.dataset.letter,
                        index: parseInt(e.target.dataset.index)
                    }];
                    e.target.classList.add('selected');
                    this.lastCell = e.target;
                }
            }

            mouseDraw(e){
                // Extract the mouse target and process it
                this.draw(e.target, e.clientX, e.clientY);
            }

            draw(cell, clientX, clientY) {
                if (!this.isDrawing) {
                    return;
                }

                if (cell.classList.contains('grid-item') && cell !== this.lastCell) {
                    // Reject points too close to the edge sto avoid false positives
                    const cellRect = cell.getBoundingClientRect();
                    const cellCentreX = cellRect.left + (cellRect.width/2);
                    const cellCentreY = cellRect.top + (cellRect.height/2);
                    if( Math.abs( cellCentreX - clientX ) > this.tolerance || Math.abs( cellCentreY - clientY ) > this.tolerance ) {
                        return;
                    }

                    // Where are we
                    const cellIndex = parseInt(cell.dataset.index);
                    const cellCol = cellIndex % this.gridSize;
                    const cellRow = (cellIndex-cellCol) / this.gridSize;
                    
                    // Where have we come from
                    const prevIndex = this.selectedLetters[this.selectedLetters.length-1].index;
                    const prevCol = prevIndex % this.gridSize;
                    const prevRow = (prevIndex-prevCol) / this.gridSize;
                    
                    // What will help us work out if this is a valid move - valid being -1 and 1 respectively
                    const lastSelectedIndex = this.selectedLetters.findIndex(item => item.index === cellIndex);
                    const distance = Math.max(Math.abs(cellCol-prevCol),Math.abs(cellRow-prevRow));

                    // lastSelectedIndex = -1 iff cell is not part of the current selection
                    // distance = 1 if the origin and new cell are adjacent
                    
                    // if a valid move, select the square
                    if (lastSelectedIndex === -1 && distance === 1) {
                        // Add new cell to selection
                        cell.classList.add('selected');
                        this.selectedLetters.push({
                            letter: cell.dataset.letter,
                            index: cellIndex
                        });
                        this.drawLine(this.lastCell, cell);

                        this.lastCell = cell;
                    } else if (lastSelectedIndex !== -1) {
                        // Encountered an already selected cell. Is this a step backwards
                        if (cellIndex === this.selectedLetters[this.selectedLetters.length-2]?.index) {
                            // Pop the last selected letter and deselect its cell

                            const prevIndex = this.selectedLetters[this.selectedLetters.length-1].index;
                            const prevCell = this.grid.childNodes[prevIndex];
                            prevCell.classList.remove('selected');

                            this.trail.removeChild(this.trail.lastChild);
                            this.selectedLetters.pop();
        
                            this.lastCell = cell;
                        }
                    }
                }
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    console.log(
                        'Selected letters:', 
                        this.selectedLetters.map(item => item.letter).join('')
                    );
                    this.clearTrail();
                    document.querySelectorAll('.grid-item')
                        .forEach(item => item.classList.remove('selected'));
                }
            }

            drawLine(from, to) {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x',from.getBoundingClientRect().left);
                rect.setAttribute('y',from.getBoundingClientRect().top);
                rect.setAttribute('width',from.getBoundingClientRect().width);
                rect.setAttribute('height',from.getBoundingClientRect().height);
                rect.setAttribute('fill','blue');
                this.trail.appendChild(rect);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();
                
                line.setAttribute('x1', fromRect.left + (fromRect.width / 2));
                line.setAttribute('y1', fromRect.top + (fromRect.height / 2));
                line.setAttribute('x2', toRect.left + (toRect.width / 2));
                line.setAttribute('y2', toRect.top + (toRect.height / 2));
                line.setAttribute('stroke', 'rgba(111, 176, 92, 0.5)');
                line.setAttribute('stroke-width', '11');
                this.trail.appendChild(line);
            }

            clearTrail() {
                while (this.trail.firstChild) {
                    this.trail.removeChild(this.trail.firstChild);
                }
            }
        }

        // Initialize the grid when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new LetterGrid();
        });
    </script>
</body>
</html>
